{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tokenomics Blockchain Decentralization - Documentation This is the documentation for the Tokenomics Decentralization Analysis tool developed by the University of Edinburgh's Blockchain Technology Lab. The tool is responsible for analyzing the token distribution of various blockchains and measuring their subsequent levels of decentralization. The relevant source code is available on GitHub . Overview Currently, the supported ledgers are: Bitcoin Bitcoin Cash Dogecoin Ethereum Litecoin Tezos We intend to add more ledgers to this list in the future. Contributing This is an open source project licensed under the terms and conditions of the MIT license and CC BY-SA 4.0 . Everyone is welcome to contribute to it by proposing or implementing their ideas. Example contributions include, but are not limited to, reporting potential bugs, supplying useful information for the clustering of supported ledgers, adding support for a new ledger, or making the code more efficient. All contributions to the project will also be covered by the above-mentioned license. When making changes in the code, contributors are required to fork the project's repository first and then issue a pull request with their changes. Each PR will be reviewed before being merged to the main branch. Bugs can be reported in the Issues page. Other comments and ideas can be brought up in the project's Discussions . For more information on how to make specific contributions, see How to Contribute .","title":"Home"},{"location":"#tokenomics-blockchain-decentralization-documentation","text":"This is the documentation for the Tokenomics Decentralization Analysis tool developed by the University of Edinburgh's Blockchain Technology Lab. The tool is responsible for analyzing the token distribution of various blockchains and measuring their subsequent levels of decentralization. The relevant source code is available on GitHub .","title":"Tokenomics Blockchain Decentralization - Documentation"},{"location":"#overview","text":"Currently, the supported ledgers are: Bitcoin Bitcoin Cash Dogecoin Ethereum Litecoin Tezos We intend to add more ledgers to this list in the future.","title":"Overview"},{"location":"#contributing","text":"This is an open source project licensed under the terms and conditions of the MIT license and CC BY-SA 4.0 . Everyone is welcome to contribute to it by proposing or implementing their ideas. Example contributions include, but are not limited to, reporting potential bugs, supplying useful information for the clustering of supported ledgers, adding support for a new ledger, or making the code more efficient. All contributions to the project will also be covered by the above-mentioned license. When making changes in the code, contributors are required to fork the project's repository first and then issue a pull request with their changes. Each PR will be reviewed before being merged to the main branch. Bugs can be reported in the Issues page. Other comments and ideas can be brought up in the project's Discussions . For more information on how to make specific contributions, see How to Contribute .","title":"Contributing"},{"location":"contribute/","text":"How to contribute You can contribute to the tool by adding support for a ledger, updating the mapping process for an existing ledger, or adding a new metric. In all cases, the information should be submitted via a GitHub PR. ...","title":"How to contribute"},{"location":"contribute/#how-to-contribute","text":"You can contribute to the tool by adding support for a ledger, updating the mapping process for an existing ledger, or adding a new metric. In all cases, the information should be submitted via a GitHub PR. ...","title":"How to contribute"},{"location":"data/","text":"Data collection Currently, the data for the analysis of the different ledgers is collected through Google BigQuery . Queries One can retrieve the data directly from BigQuery using the queries below: Bitcoin WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_bitcoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_bitcoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC Bitcoin Cash WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_bitcoin_cash.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_bitcoin_cash.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC Cardano SELECT * FROM ( WITH blocks AS ( SELECT slot_no AS block_number, block_time FROM `iog-data-analytics.cardano_mainnet.block` WHERE block_time < \"{{timestamp}}\" ), OUTPUTS AS ( SELECT slot_no as output_slot_number, CAST(JSON_VALUE(a, '$.out_address') AS STRING) AS address, CAST(JSON_VALUE(a, '$.out_idx') AS INT64) as out_idx, CAST(JSON_VALUE(a, '$.out_value') AS INT64 ) AS value FROM `iog-data-analytics.cardano_mainnet.vw_tx_in_out_with_inputs_value` JOIN blocks ON block_number = slot_no JOIN UNNEST(JSON_QUERY_ARRAY(outputs)) AS a ), INPUTS AS ( SELECT address, CAST(JSON_VALUE(i, '$.out_value') AS INT64 ) AS value FROM `iog-data-analytics.cardano_mainnet.vw_tx_in_out_with_inputs_value` JOIN OUTPUTS ON slot_no = output_slot_number JOIN UNNEST(JSON_QUERY_ARRAY(inputs)) AS i ON CAST(JSON_VALUE(i, '$.in_idx') AS INT64) = OUTPUTS.out_idx ), INCOMING AS ( SELECT address, SUM(CAST(value AS numeric)) as sum_incoming FROM INPUTS GROUP BY address ), OUTGOING AS ( SELECT address, SUM(CAST(value AS numeric)) as sum_outgoing FROM OUTPUTS GROUP BY address ) SELECT i.address, i.sum_incoming - o.sum_outgoing AS balance FROM INCOMING AS i JOIN OUTGOING AS o ON i.address = o.address ) WHERE balance > 0 ORDER BY balance DESC Dogecoin WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_dogecoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_dogecoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC Ethereum WITH double_entry_book AS ( SELECT to_address as address, value AS value FROM `bigquery-public-data.crypto_ethereum.traces` WHERE to_address IS NOT null AND status = 1 AND (call_type NOT IN ('delegatecall', 'callcode', 'staticcall') OR call_type IS null) AND block_timestamp < \"{{timestamp}}\" UNION ALL SELECT from_address as address, -value AS value FROM `bigquery-public-data.crypto_ethereum.traces` WHERE from_address IS NOT null AND status = 1 AND (call_type NOT IN ('delegatecall', 'callcode', 'staticcall') OR call_type IS null) AND block_timestamp < \"{{timestamp}}\" UNION ALL SELECT miner AS address, sum(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) AS value FROM `bigquery-public-data.crypto_ethereum.transactions` AS transactions JOIN `bigquery-public-data.crypto_ethereum.blocks` AS blocks on blocks.number = transactions.block_number WHERE transactions.block_timestamp < \"{{timestamp}}\" GROUP BY blocks.miner UNION ALL SELECT from_address AS address, -(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) AS value FROM `bigquery-public-data.crypto_ethereum.transactions` WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, sum(value) AS balance FROM double_entry_book GROUP BY address HAVING balance > 0 ORDER BY balance DESC Litecoin WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_litecoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_litecoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC Tezos WITH double_entry_book as ( SELECT IF(kind = 'contract', contract, delegate) AS address, change AS value FROM `public-data-finance.crypto_tezos.balance_updates` WHERE (status IS NULL OR status = 'applied') AND (timestamp < \"{{timestamp}}\") UNION ALL SELECT address, balance_change FROM `public-data-finance.crypto_tezos.migrations` WHERE timestamp < \"{{timestamp}}\" ) SELECT address, SUM(value) AS balance FROM double_entry_book GROUP BY address HAVING balance > 0 ORDER BY balance DESC Zcash WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_zcash.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_zcash.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC Automating the data collection process Instead of executing each of these queries separately on the BigQuery console and saving the results manually, it is also possible to automate the process using a script and collect all relevant data in one go. Executing this script will run queries from this file . IMPORTANT: the script uses service account credentials for authentication, therefore before running it, you need to generate the relevant credentials from Google, as described here and save your key in the data_collections_scripts/ directory of the project under the name 'google-service-account-key-0.json'. Any additional keys should be named 'google-service-account-key-1.json', 'google-service-account-key-2.json', and so on. There is a sample file that you can consult, which shows what your credentials are supposed to look like (but note that this is for informational purposes only, this file is not used in the code). Once you have set up the credentials, you can just run the following command from the root directory to retrieve data for all supported blockchains: python -m data_collection_scripts.big_query_balance_data There are also three command line arguments that can be used to customize the data collection process: ledgers accepts any number of the supported ledgers (case-insensitive). For example, adding --ledgers bitcoin results in collecting data only for Bitcoin, while --ledgers Bitcoin Ethereum would collect data for Bitcoin and Ethereum. If the ledgers argument is omitted, then the default value is used, which is taken from the configuration file and typically corresponds to all supported blockchains. snapshot_dates accepts any number of dates formatted as YYYY-MM-DD, YYYY-MM, or YYYY. Then, data is collected for the specified date(s). Again, if this argument is omitted, the default value is taken from the configuration file . --force-query forces the collection of all raw data files, even if some or all of the files already exist. By default, this flag is set to False and the script only fetches data for some blockchain if the corresponding file does not already exist.","title":"Data Collection"},{"location":"data/#data-collection","text":"Currently, the data for the analysis of the different ledgers is collected through Google BigQuery .","title":"Data collection"},{"location":"data/#queries","text":"One can retrieve the data directly from BigQuery using the queries below:","title":"Queries"},{"location":"data/#bitcoin","text":"WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_bitcoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_bitcoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC","title":"Bitcoin"},{"location":"data/#bitcoin-cash","text":"WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_bitcoin_cash.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_bitcoin_cash.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC","title":"Bitcoin Cash"},{"location":"data/#cardano","text":"SELECT * FROM ( WITH blocks AS ( SELECT slot_no AS block_number, block_time FROM `iog-data-analytics.cardano_mainnet.block` WHERE block_time < \"{{timestamp}}\" ), OUTPUTS AS ( SELECT slot_no as output_slot_number, CAST(JSON_VALUE(a, '$.out_address') AS STRING) AS address, CAST(JSON_VALUE(a, '$.out_idx') AS INT64) as out_idx, CAST(JSON_VALUE(a, '$.out_value') AS INT64 ) AS value FROM `iog-data-analytics.cardano_mainnet.vw_tx_in_out_with_inputs_value` JOIN blocks ON block_number = slot_no JOIN UNNEST(JSON_QUERY_ARRAY(outputs)) AS a ), INPUTS AS ( SELECT address, CAST(JSON_VALUE(i, '$.out_value') AS INT64 ) AS value FROM `iog-data-analytics.cardano_mainnet.vw_tx_in_out_with_inputs_value` JOIN OUTPUTS ON slot_no = output_slot_number JOIN UNNEST(JSON_QUERY_ARRAY(inputs)) AS i ON CAST(JSON_VALUE(i, '$.in_idx') AS INT64) = OUTPUTS.out_idx ), INCOMING AS ( SELECT address, SUM(CAST(value AS numeric)) as sum_incoming FROM INPUTS GROUP BY address ), OUTGOING AS ( SELECT address, SUM(CAST(value AS numeric)) as sum_outgoing FROM OUTPUTS GROUP BY address ) SELECT i.address, i.sum_incoming - o.sum_outgoing AS balance FROM INCOMING AS i JOIN OUTGOING AS o ON i.address = o.address ) WHERE balance > 0 ORDER BY balance DESC","title":"Cardano"},{"location":"data/#dogecoin","text":"WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_dogecoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_dogecoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC","title":"Dogecoin"},{"location":"data/#ethereum","text":"WITH double_entry_book AS ( SELECT to_address as address, value AS value FROM `bigquery-public-data.crypto_ethereum.traces` WHERE to_address IS NOT null AND status = 1 AND (call_type NOT IN ('delegatecall', 'callcode', 'staticcall') OR call_type IS null) AND block_timestamp < \"{{timestamp}}\" UNION ALL SELECT from_address as address, -value AS value FROM `bigquery-public-data.crypto_ethereum.traces` WHERE from_address IS NOT null AND status = 1 AND (call_type NOT IN ('delegatecall', 'callcode', 'staticcall') OR call_type IS null) AND block_timestamp < \"{{timestamp}}\" UNION ALL SELECT miner AS address, sum(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) AS value FROM `bigquery-public-data.crypto_ethereum.transactions` AS transactions JOIN `bigquery-public-data.crypto_ethereum.blocks` AS blocks on blocks.number = transactions.block_number WHERE transactions.block_timestamp < \"{{timestamp}}\" GROUP BY blocks.miner UNION ALL SELECT from_address AS address, -(cast(receipt_gas_used as numeric) * cast(gas_price as numeric)) AS value FROM `bigquery-public-data.crypto_ethereum.transactions` WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, sum(value) AS balance FROM double_entry_book GROUP BY address HAVING balance > 0 ORDER BY balance DESC","title":"Ethereum"},{"location":"data/#litecoin","text":"WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_litecoin.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_litecoin.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC","title":"Litecoin"},{"location":"data/#tezos","text":"WITH double_entry_book as ( SELECT IF(kind = 'contract', contract, delegate) AS address, change AS value FROM `public-data-finance.crypto_tezos.balance_updates` WHERE (status IS NULL OR status = 'applied') AND (timestamp < \"{{timestamp}}\") UNION ALL SELECT address, balance_change FROM `public-data-finance.crypto_tezos.migrations` WHERE timestamp < \"{{timestamp}}\" ) SELECT address, SUM(value) AS balance FROM double_entry_book GROUP BY address HAVING balance > 0 ORDER BY balance DESC","title":"Tezos"},{"location":"data/#zcash","text":"WITH double_entry_book AS ( SELECT array_to_string(inputs.addresses, \",\") as address, inputs.type, -inputs.value as value FROM `bigquery-public-data.crypto_zcash.inputs` as inputs WHERE block_timestamp < \"{{timestamp}}\" UNION ALL SELECT array_to_string(outputs.addresses, \",\") as address, outputs.type, outputs.value as value FROM `bigquery-public-data.crypto_zcash.outputs` as outputs WHERE block_timestamp < \"{{timestamp}}\" ) SELECT address, type, sum(value) as balance FROM double_entry_book GROUP BY 1,2 HAVING balance > 0 ORDER BY balance DESC","title":"Zcash"},{"location":"data/#automating-the-data-collection-process","text":"Instead of executing each of these queries separately on the BigQuery console and saving the results manually, it is also possible to automate the process using a script and collect all relevant data in one go. Executing this script will run queries from this file . IMPORTANT: the script uses service account credentials for authentication, therefore before running it, you need to generate the relevant credentials from Google, as described here and save your key in the data_collections_scripts/ directory of the project under the name 'google-service-account-key-0.json'. Any additional keys should be named 'google-service-account-key-1.json', 'google-service-account-key-2.json', and so on. There is a sample file that you can consult, which shows what your credentials are supposed to look like (but note that this is for informational purposes only, this file is not used in the code). Once you have set up the credentials, you can just run the following command from the root directory to retrieve data for all supported blockchains: python -m data_collection_scripts.big_query_balance_data There are also three command line arguments that can be used to customize the data collection process: ledgers accepts any number of the supported ledgers (case-insensitive). For example, adding --ledgers bitcoin results in collecting data only for Bitcoin, while --ledgers Bitcoin Ethereum would collect data for Bitcoin and Ethereum. If the ledgers argument is omitted, then the default value is used, which is taken from the configuration file and typically corresponds to all supported blockchains. snapshot_dates accepts any number of dates formatted as YYYY-MM-DD, YYYY-MM, or YYYY. Then, data is collected for the specified date(s). Again, if this argument is omitted, the default value is taken from the configuration file . --force-query forces the collection of all raw data files, even if some or all of the files already exist. By default, this flag is set to False and the script only fetches data for some blockchain if the corresponding file does not already exist.","title":"Automating the data collection process"},{"location":"metrics/","text":"Metrics The metrics that have been implemented so far are the following: Nakamoto coefficient : The Nakamoto coefficient represents the minimum number of entities that collectively produce more than 50% of the total blocks within a given timeframe. The output of the metric is an integer. Gini coefficient : The Gini coefficient represents the degree of inequality in block production. The output of the metric is a decimal number in [0,1]. Values close to 0 indicate equality (all entities in the system produce the same number of blocks) and values close to 1 indicate inequality (one entity produces most or all blocks). Entropy : Entropy represents the expected amount of information in the distribution of blocks across entities. The output of the metric is a real number. Typically, a higher value of entropy indicates higher decentralization (lower predictability). Entropy is parameterized by a base rate \u03b1, which defines different types of entropy: \u03b1 = -1: min entropy \u03b1 = 0: Hartley entropy \u03b1 = 1: Shannon entropy (this is used by default) \u03b1 = 2: collision entropy HHI : The Herfindahl-Hirschman Index (HHI) is a measure of market concentration. It is defined as the sum of the squares of the market shares (as whole numbers, e.g. 40 for 40%) of the entities in the system. The output of the metric is a real number in (0, 10000]. Values close to 0 indicate low concentration (many entities produce a similar number of blocks) and values close to 1 indicate high concentration (one entity produces most or all blocks). The U.S. Department of Justice has set the following thresholds for interpreting HHI values (in traditional markets): (0, 1500): Competitive market [1500, 2500]: Moderately concentrated market (2500, 10000]: Highly concentrated market Theil index : The Theil index is another measure of entropy which is intended to capture the lack of diversity, or the redundancy, in a population. In practice, it is calculated as the maximum possible entropy minus the observed entropy. The output is a real number. Values close to 0 indicate equality and values towards infinity indicate inequality. Therefore, a high Theil Index suggests a population that is highly centralized. Max power ratio : The max power ratio represents the share of blocks that are produced by the most \"powerful\" entity, i.e. the entity that produces the most blocks. The output of the metric is a decimal number in [0,1]. Tau-decentralization index : The tau-decentralization index is a generalization of the Nakamoto coefficient. It is defined as the minimum number of entities that collectively produce more than a given threshold of the total blocks within a given timeframe. The threshold parameter is a decimal in [0, 1] (0.66 by default) and the output of the metric is an integer.","title":"Metrics"},{"location":"metrics/#metrics","text":"The metrics that have been implemented so far are the following: Nakamoto coefficient : The Nakamoto coefficient represents the minimum number of entities that collectively produce more than 50% of the total blocks within a given timeframe. The output of the metric is an integer. Gini coefficient : The Gini coefficient represents the degree of inequality in block production. The output of the metric is a decimal number in [0,1]. Values close to 0 indicate equality (all entities in the system produce the same number of blocks) and values close to 1 indicate inequality (one entity produces most or all blocks). Entropy : Entropy represents the expected amount of information in the distribution of blocks across entities. The output of the metric is a real number. Typically, a higher value of entropy indicates higher decentralization (lower predictability). Entropy is parameterized by a base rate \u03b1, which defines different types of entropy: \u03b1 = -1: min entropy \u03b1 = 0: Hartley entropy \u03b1 = 1: Shannon entropy (this is used by default) \u03b1 = 2: collision entropy HHI : The Herfindahl-Hirschman Index (HHI) is a measure of market concentration. It is defined as the sum of the squares of the market shares (as whole numbers, e.g. 40 for 40%) of the entities in the system. The output of the metric is a real number in (0, 10000]. Values close to 0 indicate low concentration (many entities produce a similar number of blocks) and values close to 1 indicate high concentration (one entity produces most or all blocks). The U.S. Department of Justice has set the following thresholds for interpreting HHI values (in traditional markets): (0, 1500): Competitive market [1500, 2500]: Moderately concentrated market (2500, 10000]: Highly concentrated market Theil index : The Theil index is another measure of entropy which is intended to capture the lack of diversity, or the redundancy, in a population. In practice, it is calculated as the maximum possible entropy minus the observed entropy. The output is a real number. Values close to 0 indicate equality and values towards infinity indicate inequality. Therefore, a high Theil Index suggests a population that is highly centralized. Max power ratio : The max power ratio represents the share of blocks that are produced by the most \"powerful\" entity, i.e. the entity that produces the most blocks. The output of the metric is a decimal number in [0,1]. Tau-decentralization index : The tau-decentralization index is a generalization of the Nakamoto coefficient. It is defined as the minimum number of entities that collectively produce more than a given threshold of the total blocks within a given timeframe. The threshold parameter is a decimal in [0, 1] (0.66 by default) and the output of the metric is an integer.","title":"Metrics"},{"location":"setup/","text":"Setup Installation To install the tokenomics decentralization analysis tool, simply clone this GitHub repository: git clone https://github.com/Blockchain-Technology-Lab/tokenomics-decentralization.git The tool is written in Python 3, therefore a Python 3 interpreter is required in order to run it locally. The requirements file lists the dependencies of the project. Make sure you have all of them installed before running the scripts. To install all of them in one go, run the following command from the root directory of the project: python -m pip install -r requirements.txt Execution The tokenomics decentralization analysis tool is a CLI tool. The following process describes the most typical workflow. ...","title":"How to use"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#installation","text":"To install the tokenomics decentralization analysis tool, simply clone this GitHub repository: git clone https://github.com/Blockchain-Technology-Lab/tokenomics-decentralization.git The tool is written in Python 3, therefore a Python 3 interpreter is required in order to run it locally. The requirements file lists the dependencies of the project. Make sure you have all of them installed before running the scripts. To install all of them in one go, run the following command from the root directory of the project: python -m pip install -r requirements.txt","title":"Installation"},{"location":"setup/#execution","text":"The tokenomics decentralization analysis tool is a CLI tool. The following process describes the most typical workflow. ...","title":"Execution"}]}